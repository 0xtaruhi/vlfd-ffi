use std::{fs, path::Path};

fn main() {
    println!("cargo:rerun-if-changed=src/lib.rs");

    let crate_dir = std::env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR not set");
    let out_dir = std::env::var("OUT_DIR").expect("OUT_DIR not set");
    let header_path = Path::new(&out_dir).join("vlfd_ffi.h");

    if Path::new(&crate_dir).join("cbindgen.toml").exists() {
        println!("cargo:rerun-if-changed=cbindgen.toml");
    }

    let config = cbindgen::Config {
        language: cbindgen::Language::C,
        usize_is_size_t: true,
        cpp_compat: true,
        no_includes: false,
        header: Some(String::from("// Auto-generated by cbindgen. Do not edit.")),
        include_guard: Some(String::from("CBINDGEN__VLFD_FFI_H")),
        ..Default::default()
    };

    cbindgen::Builder::new()
        .with_crate(&crate_dir)
        .with_config(config)
        .generate()
        .expect("Unable to generate bindings")
        .write_to_file(&header_path);

    println!("cargo:include={}", out_dir);

    let package_marker = format!("{sep}target{sep}package{sep}", sep = std::path::MAIN_SEPARATOR);
    let running_in_package_dir = crate_dir.contains(&package_marker) || crate_dir.contains("/target/package/");

    if !running_in_package_dir {
        let display_path = Path::new(&crate_dir).join("vlfd_ffi.h");
        if let Err(err) = fs::copy(&header_path, &display_path) {
            println!("cargo:warning=Failed to copy header to {}: {}", display_path.display(), err);
        } else {
            println!("cargo:warning=Generated C header at {}", display_path.display());
        }
    }
}
